{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"93530922e918ed1a4d8064641995786cb0771416","modified":1473391344000},{"_id":"source/_posts/life-simple.md","hash":"a52c063d77a00840eb9cdab874f8f91a9b0eedb5","modified":1473391344000},{"_id":"source/_posts/sync_blog/Maven 分享.md","hash":"77038db7ea3e373152ea94d6402b9859d690e980","modified":1473392907000},{"_id":"source/_posts/life-simple/lijiang.jpg","hash":"e3d95a8e89a5eef018869daa41b9320441a562e6","modified":1473391344000},{"_id":"public/2016/09/06/sync_blog/Maven 分享/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473393535546},{"_id":"public/2015/06/16/life-simple/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473393535546},{"_id":"public/2015/06/16/hello-world/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473393535546},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473393535547},{"_id":"public/archives/2015/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473393535547},{"_id":"public/archives/2015/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473393535547},{"_id":"public/archives/2016/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473393535547},{"_id":"public/archives/2016/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473393535547},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473393535547},{"_id":"public/tags/始/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473393535547},{"_id":"public/tags/随想/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1473393535548},{"_id":"public/2015/06/16/life-simple/lijiang.jpg","hash":"e3d95a8e89a5eef018869daa41b9320441a562e6","modified":1473393535555},{"_id":"source/_posts/sync_blog/.DS_Store","hash":"d580446426da47b14005dbf2ef5ff7c39c29fcf1","modified":1473395797000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hello, World!","date":"2015-06-16T07:22:22.000Z","_content":"\n> 在 Programmer 的世界里, Hello World 永远是第一个老师. 就像刚刚折腾到的个人博客~, ta 还是第一个出生的~. \n\n\n\n\tSystem.out.println(\"Hello, World!\");  // Java\n\n\tprint u'Hello, World!'  # python\n\t\n\tconsole.log('Hello, World!');   // Javascript & nodejs\n\t\n\tprintf(\"Hello, World!\");   /* c */\n\t\n\tcout << \"Hello, World!\" << endl;   /* c++ */\n\t\n\tprintln(\"Hello, World!\")\t// Swift\n\t\n\tNSLog (@\"Hello, World!\")   /* Objective-C */\n\t\n\n> 博客框架选取: [Hexo](http://hexo.io/)\n\n\n\n\n","source":"_posts/hello-world.md","raw":"title: Hello, World!\ndate: 2015-06-16 15:22:22\ntags: 始\n---\n\n> 在 Programmer 的世界里, Hello World 永远是第一个老师. 就像刚刚折腾到的个人博客~, ta 还是第一个出生的~. \n\n\n\n\tSystem.out.println(\"Hello, World!\");  // Java\n\n\tprint u'Hello, World!'  # python\n\t\n\tconsole.log('Hello, World!');   // Javascript & nodejs\n\t\n\tprintf(\"Hello, World!\");   /* c */\n\t\n\tcout << \"Hello, World!\" << endl;   /* c++ */\n\t\n\tprintln(\"Hello, World!\")\t// Swift\n\t\n\tNSLog (@\"Hello, World!\")   /* Objective-C */\n\t\n\n> 博客框架选取: [Hexo](http://hexo.io/)\n\n\n\n\n","slug":"hello-world","published":1,"updated":"2016-09-09T03:22:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cisv8gvw20000bumrm0wv126d","content":"<blockquote>\n<p>在 Programmer 的世界里, Hello World 永远是第一个老师. 就像刚刚折腾到的个人博客~, ta 还是第一个出生的~. </p>\n</blockquote>\n<pre><code>System.out.println(&quot;Hello, World!&quot;);  // Java\n\nprint u&apos;Hello, World!&apos;  # python\n\nconsole.log(&apos;Hello, World!&apos;);   // Javascript &amp; nodejs\n\nprintf(&quot;Hello, World!&quot;);   /* c */\n\ncout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;   /* c++ */\n\nprintln(&quot;Hello, World!&quot;)    // Swift\n\nNSLog (@&quot;Hello, World!&quot;)   /* Objective-C */\n</code></pre><blockquote>\n<p>博客框架选取: <a href=\"http://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a></p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>在 Programmer 的世界里, Hello World 永远是第一个老师. 就像刚刚折腾到的个人博客~, ta 还是第一个出生的~. </p>\n</blockquote>\n<pre><code>System.out.println(&quot;Hello, World!&quot;);  // Java\n\nprint u&apos;Hello, World!&apos;  # python\n\nconsole.log(&apos;Hello, World!&apos;);   // Javascript &amp; nodejs\n\nprintf(&quot;Hello, World!&quot;);   /* c */\n\ncout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;   /* c++ */\n\nprintln(&quot;Hello, World!&quot;)    // Swift\n\nNSLog (@&quot;Hello, World!&quot;)   /* Objective-C */\n</code></pre><blockquote>\n<p>博客框架选取: <a href=\"http://hexo.io/\">Hexo</a></p>\n</blockquote>\n"},{"title":"生活本该这样","date":"2015-06-16T08:24:52.000Z","_content":"\n{% asset_img lijiang.jpg %}\n\n你看, 生活好像本就该这样, 有一点小小的追求, 一点小小的期望.  随心, 随性的活着. 会遇到一点挫折, 会感到一点辛苦. 就好像一切都是那么的自然而然. 我们努力去感受平凡中那点滴的幸福, 而在一切的不如意的面前, 幸福也才显得更加弥足珍贵.\n\n你说呢?\n","source":"_posts/life-simple.md","raw":"title: 生活本该这样\ndate: 2015-06-16 16:24:52\ntags: 随想\n---\n\n{% asset_img lijiang.jpg %}\n\n你看, 生活好像本就该这样, 有一点小小的追求, 一点小小的期望.  随心, 随性的活着. 会遇到一点挫折, 会感到一点辛苦. 就好像一切都是那么的自然而然. 我们努力去感受平凡中那点滴的幸福, 而在一切的不如意的面前, 幸福也才显得更加弥足珍贵.\n\n你说呢?\n","slug":"life-simple","published":1,"updated":"2016-09-09T03:22:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cisv8gvw70001bumr5481pohe","content":"<img src=\"/2015/06/16/life-simple/lijiang.jpg\" alt=\"lijiang.jpg\" title=\"\">\n<p>你看, 生活好像本就该这样, 有一点小小的追求, 一点小小的期望.  随心, 随性的活着. 会遇到一点挫折, 会感到一点辛苦. 就好像一切都是那么的自然而然. 我们努力去感受平凡中那点滴的幸福, 而在一切的不如意的面前, 幸福也才显得更加弥足珍贵.</p>\n<p>你说呢?</p>\n","excerpt":"","more":"<img src=\"/2015/06/16/life-simple/lijiang.jpg\" alt=\"lijiang.jpg\" title=\"\">\n<p>你看, 生活好像本就该这样, 有一点小小的追求, 一点小小的期望.  随心, 随性的活着. 会遇到一点挫折, 会感到一点辛苦. 就好像一切都是那么的自然而然. 我们努力去感受平凡中那点滴的幸福, 而在一切的不如意的面前, 幸福也才显得更加弥足珍贵.</p>\n<p>你说呢?</p>\n"},{"_content":"# Maven 是什么？\n\n## 序\n\nMaven 是什么？ \n\n>  Maven 是一种工具。 \n\n工具又是用来干嘛的呢？\n\n>  工具是用来解决目前大家遇到的一些共性的、复杂的、耗时的问题。\n\n那么， Maven 是用来解决哪些问题的呢？\n\n\n## 过去\n\n在很久很久以前，我们在新建项目时，需要添加项目的源码目录 `src`，包目录 `lib`，资源目录 `WebRoot/WebContent/web` 等等.\n\n![Openfire 源码目录](http://7xjzby.com1.z0.glb.clouddn.com/openfire_src_dir_160909_1.png)![Simple Web src dir](http://7xjzby.com1.z0.glb.clouddn.com/simple_web_src_dir_160909.png)\n\n\n\n我们可以发现， 不同项目的目录结构，各有各的风格。\n\n这就会让我们在接触一个新的项目时，感到困惑。也不利于初学者的入门。\n\n\n\n然后，我们需要去不同的网站上下载项目所需要依赖的各种 jar 包，比如 Spring，junit 等等。 找 jar 包这个过程很痛苦， 做过的人都应该有所了解。 \n\n而比较有经验的工程师可能都会有自己的一个 jar 库， 当然， jar 的版本比较老也是免不了的。\n\n在这个过程中， 我们需要找到合适的版本比如 aspectjrt-1.5.1.jar， 合适的依赖包 aspectjweaver-1.5.1.jar。\n多个 jar 包之间版本要兼容等等相关的问题。比如 spring-2.5.6.jar 需要依赖 slf4j-1.3.jar， 而 MyBatis 可能需要依赖 slf4j-1.5.jar. 这个时候还需要解决重复依赖的问题， 选择一个更兼容的版本。\n\njar 包找齐之后， 我们还需要把对于 jar 包的依赖，添加到项目的 classpath 中（eclipse，不同的 IDE 下 classpath 的依赖是不同的)。\n\n\n在最终的版本库（svn）中，除了项目必要的源码，可能还会包含各种 jar 包以及 classpath 之类相关 IDE 配置。\n\n总而言之，解决 jar 包的依赖，是传统的项目开发中一项不容忽视的工作。\n\n目前来看，至少有三个比较繁琐的步骤：\n\n1. 项目目录结构的生成， 规范性；\n2. 和 jar 包相关的使用和管理，依赖问题；\n3. 在版本库中包含了过多与项目自身无关的内容；\n\n## 现在\n\n那么 Maven 是又通过哪种方式解决了这个繁琐的问题？\n\nMaven 使用惯例优于配置的原则。\n\n它要求在没有定制之前，所有的项目都有如下的结构： \n\n| 目录                            | 目的                              |\n| :---------------------------- | ------------------------------- |\n| ${basedir}                    | 存放 pom.xml和所有的子目录               |\n| ${basedir}/src/main/java      | 项目的 java源代码                     |\n| ${basedir}/src/main/resources | 项目资源，如各种配置文件                    |\n| ${basedir}/src/test/java      | 项目的测试类，比如说 JUnit代码              |\n| ${basedir}/src/test/resources | 测试使用的资源                         |\n| ${basedir}/src/main/webapp    | 存放所有的 Web 资源, 比如 WEB-INF, 静态资源等 |\n\nMaven 为什么要使用惯例优于配置的原则？\n一方面，统一项目结构，降低大家看到新项目时的学习成本；\n另一方面，方便我们直接进行使用；\n\n> 演示 Maven 新建项目, 展示默认约定的目录结构\n>\n> 引入 pom & mvn 项目常用的生命周期\n>\n> 引入 介绍 .m2 目录下的 .settings & repository\n\n\n\nMaven 提供了一种方式， 让每一个组件都可以拥有自己的 location 坐标。\ngroupId + articleId + version + [type]。\neg.  `org.springframework.spring-mvc-3.2.2.jar`\n\n\t<dependency>\n\t    <groupId>org.springframework</groupId>\n\t    <artifactId>spring-mvc</artifactId>\n\t    <version>3.2.2</version>\n\t</dependency>\n\n\n通过在项目中配置所需依赖包的 location， 我们就可以让项目自动依赖所需的 jar 包。\njar 包之间所有的依赖关系， maven 会自动进行处理。当然我们可以通过手工修改配置的方式来制定不同的依赖版本， 但大多数情况下是不必要的。 \n\n\n## 场景\n\n不知道大家过去有没有开发过存在多个项目依赖的 Web应用。 \n\n假如， 现在有这样一个场景， 公司 C 有多个项目组， 其中有架构组（F） 负责缓存 日志等公用服务，基础资源组（B） - 有系统公用资源层的开发 负责用户 角色 资源的基础服务， Web 应用开发组（W） - 负责最终的商业项目开发， 还有负责不同业务线的开发小组。 \n\n现在， 我们的系统架构是这样\n\nWeb 应用 1\n业务组件 A | 业务组件 B \n基础资源组件 \n架构组件\n\n\nWeb 应用 2\n业务组件 A | 业务组件 C\n基础资源组件 \n架构组件\n\n上面是公司的技术部架构\n\n接下来，说一下项目的具体场景\n\n我们的 Web 应用 1， 假设目前的  Release 版本号是 2.0.   它所依赖的架构组件， 版本号是 0.1. \n现在因为发现了一个安全问题， 版本号要更新到最新的  0.2.\n\n传统的步骤：\n\t1. 架构组 打包项目， F-0.2.jar\n\t2. 把打包好的组件发给其他项目组， 并通知其他项目组， 替换 组件\n\t3. 所有涉及到的项目，备份 F-0.1.jar , 升级到 F-0.2.jar ， 如果 F-0.2.jar 有了新的依赖 比如 aspect.jar， 那么我们的项目中也需要导入它所依赖的 jar 包\n\t> 解决jar 包依赖问题一直都是很烦人的问题\n\t4. 测试 - 如果组件 A 存在问题， 重复 1 - 4 步\n\t5. 发布项目\n\nMaven：\n\t1. 修改项目版本号， deploy 到 maven 私有仓库（存放 jar 包的地方）\n\t2. 邮件通知到相关项目组， 更新版本号\n\t3. 涉及到的项目更新组件版本号\n\t4. 测试 - 如果组件出现问题， 重复执行  deploy，通知相关人员，测试 即可， 不需要不断的发包给别人 也无需解决 jar 依赖的问题\n\t5. 发布项目\n\n\n## 介绍\n\nMaven 是一个项目管理 & 构建自动化工具。\n它有很强大的依赖管理功能， 可以帮助我们简化项目之间的依赖关系。\n\n\n### 依赖管理 \n\n怎么理解呢？\n\n对于 Java 项目来讲， 每一个项目都会或多或少的依赖一些 jar 包。 \n而每个 jar 其实都是一个已经发布的项目。也就是说我们的项目其实已经依赖了各种各样的项目， 比如 Spring，Hibernate etc.. \n从另一个角度来讲，这也就意味着，我们可以通过maven， 把所有的 jar 包(项目)管理起来。\n\nQA\n\n\n### 项目管理\n\n那么，我们既然可以通过 Maven 引用别人的项目，那么是不是意味着我们自己的项目，如果是由多个子项目来构成，那也可以通过 Maven 来组织呢？\n\n\n多项目之间的依赖， 首先 第一个问题，就是我们需要通过 IDE 的项目依赖配置， 来解决开发过程中不断打 jar 包来构建依赖的问题。\n第二个就是依赖版本的控制， 这个怎么理解呢？比如 我们的 Web 应用的版本是 1.0， 而所依赖某个组件， 比如组件 A 的版本可能是 0.1。 组件 A 由专门的开发组来维护。 \n随着时间的推移， 我们的Web 应用可能升级到了 2.3， 而组件因为一直稳定所以还是0.1.  有一天突然有一个安全问题， 导致所有应用的组件 A 都需要升级到 0.5。\n步骤：\n​\t\n\n\n\n\n\n\n### 构建自动化\n\n> \n\nmaven 的生命周期指项目的构建过程，它包含了一系列有序的阶段\n\n\n## Maven 的优势\n\n","source":"_posts/sync_blog/Maven 分享.md","raw":"# Maven 是什么？\n\n## 序\n\nMaven 是什么？ \n\n>  Maven 是一种工具。 \n\n工具又是用来干嘛的呢？\n\n>  工具是用来解决目前大家遇到的一些共性的、复杂的、耗时的问题。\n\n那么， Maven 是用来解决哪些问题的呢？\n\n\n## 过去\n\n在很久很久以前，我们在新建项目时，需要添加项目的源码目录 `src`，包目录 `lib`，资源目录 `WebRoot/WebContent/web` 等等.\n\n![Openfire 源码目录](http://7xjzby.com1.z0.glb.clouddn.com/openfire_src_dir_160909_1.png)![Simple Web src dir](http://7xjzby.com1.z0.glb.clouddn.com/simple_web_src_dir_160909.png)\n\n\n\n我们可以发现， 不同项目的目录结构，各有各的风格。\n\n这就会让我们在接触一个新的项目时，感到困惑。也不利于初学者的入门。\n\n\n\n然后，我们需要去不同的网站上下载项目所需要依赖的各种 jar 包，比如 Spring，junit 等等。 找 jar 包这个过程很痛苦， 做过的人都应该有所了解。 \n\n而比较有经验的工程师可能都会有自己的一个 jar 库， 当然， jar 的版本比较老也是免不了的。\n\n在这个过程中， 我们需要找到合适的版本比如 aspectjrt-1.5.1.jar， 合适的依赖包 aspectjweaver-1.5.1.jar。\n多个 jar 包之间版本要兼容等等相关的问题。比如 spring-2.5.6.jar 需要依赖 slf4j-1.3.jar， 而 MyBatis 可能需要依赖 slf4j-1.5.jar. 这个时候还需要解决重复依赖的问题， 选择一个更兼容的版本。\n\njar 包找齐之后， 我们还需要把对于 jar 包的依赖，添加到项目的 classpath 中（eclipse，不同的 IDE 下 classpath 的依赖是不同的)。\n\n\n在最终的版本库（svn）中，除了项目必要的源码，可能还会包含各种 jar 包以及 classpath 之类相关 IDE 配置。\n\n总而言之，解决 jar 包的依赖，是传统的项目开发中一项不容忽视的工作。\n\n目前来看，至少有三个比较繁琐的步骤：\n\n1. 项目目录结构的生成， 规范性；\n2. 和 jar 包相关的使用和管理，依赖问题；\n3. 在版本库中包含了过多与项目自身无关的内容；\n\n## 现在\n\n那么 Maven 是又通过哪种方式解决了这个繁琐的问题？\n\nMaven 使用惯例优于配置的原则。\n\n它要求在没有定制之前，所有的项目都有如下的结构： \n\n| 目录                            | 目的                              |\n| :---------------------------- | ------------------------------- |\n| ${basedir}                    | 存放 pom.xml和所有的子目录               |\n| ${basedir}/src/main/java      | 项目的 java源代码                     |\n| ${basedir}/src/main/resources | 项目资源，如各种配置文件                    |\n| ${basedir}/src/test/java      | 项目的测试类，比如说 JUnit代码              |\n| ${basedir}/src/test/resources | 测试使用的资源                         |\n| ${basedir}/src/main/webapp    | 存放所有的 Web 资源, 比如 WEB-INF, 静态资源等 |\n\nMaven 为什么要使用惯例优于配置的原则？\n一方面，统一项目结构，降低大家看到新项目时的学习成本；\n另一方面，方便我们直接进行使用；\n\n> 演示 Maven 新建项目, 展示默认约定的目录结构\n>\n> 引入 pom & mvn 项目常用的生命周期\n>\n> 引入 介绍 .m2 目录下的 .settings & repository\n\n\n\nMaven 提供了一种方式， 让每一个组件都可以拥有自己的 location 坐标。\ngroupId + articleId + version + [type]。\neg.  `org.springframework.spring-mvc-3.2.2.jar`\n\n\t<dependency>\n\t    <groupId>org.springframework</groupId>\n\t    <artifactId>spring-mvc</artifactId>\n\t    <version>3.2.2</version>\n\t</dependency>\n\n\n通过在项目中配置所需依赖包的 location， 我们就可以让项目自动依赖所需的 jar 包。\njar 包之间所有的依赖关系， maven 会自动进行处理。当然我们可以通过手工修改配置的方式来制定不同的依赖版本， 但大多数情况下是不必要的。 \n\n\n## 场景\n\n不知道大家过去有没有开发过存在多个项目依赖的 Web应用。 \n\n假如， 现在有这样一个场景， 公司 C 有多个项目组， 其中有架构组（F） 负责缓存 日志等公用服务，基础资源组（B） - 有系统公用资源层的开发 负责用户 角色 资源的基础服务， Web 应用开发组（W） - 负责最终的商业项目开发， 还有负责不同业务线的开发小组。 \n\n现在， 我们的系统架构是这样\n\nWeb 应用 1\n业务组件 A | 业务组件 B \n基础资源组件 \n架构组件\n\n\nWeb 应用 2\n业务组件 A | 业务组件 C\n基础资源组件 \n架构组件\n\n上面是公司的技术部架构\n\n接下来，说一下项目的具体场景\n\n我们的 Web 应用 1， 假设目前的  Release 版本号是 2.0.   它所依赖的架构组件， 版本号是 0.1. \n现在因为发现了一个安全问题， 版本号要更新到最新的  0.2.\n\n传统的步骤：\n\t1. 架构组 打包项目， F-0.2.jar\n\t2. 把打包好的组件发给其他项目组， 并通知其他项目组， 替换 组件\n\t3. 所有涉及到的项目，备份 F-0.1.jar , 升级到 F-0.2.jar ， 如果 F-0.2.jar 有了新的依赖 比如 aspect.jar， 那么我们的项目中也需要导入它所依赖的 jar 包\n\t> 解决jar 包依赖问题一直都是很烦人的问题\n\t4. 测试 - 如果组件 A 存在问题， 重复 1 - 4 步\n\t5. 发布项目\n\nMaven：\n\t1. 修改项目版本号， deploy 到 maven 私有仓库（存放 jar 包的地方）\n\t2. 邮件通知到相关项目组， 更新版本号\n\t3. 涉及到的项目更新组件版本号\n\t4. 测试 - 如果组件出现问题， 重复执行  deploy，通知相关人员，测试 即可， 不需要不断的发包给别人 也无需解决 jar 依赖的问题\n\t5. 发布项目\n\n\n## 介绍\n\nMaven 是一个项目管理 & 构建自动化工具。\n它有很强大的依赖管理功能， 可以帮助我们简化项目之间的依赖关系。\n\n\n### 依赖管理 \n\n怎么理解呢？\n\n对于 Java 项目来讲， 每一个项目都会或多或少的依赖一些 jar 包。 \n而每个 jar 其实都是一个已经发布的项目。也就是说我们的项目其实已经依赖了各种各样的项目， 比如 Spring，Hibernate etc.. \n从另一个角度来讲，这也就意味着，我们可以通过maven， 把所有的 jar 包(项目)管理起来。\n\nQA\n\n\n### 项目管理\n\n那么，我们既然可以通过 Maven 引用别人的项目，那么是不是意味着我们自己的项目，如果是由多个子项目来构成，那也可以通过 Maven 来组织呢？\n\n\n多项目之间的依赖， 首先 第一个问题，就是我们需要通过 IDE 的项目依赖配置， 来解决开发过程中不断打 jar 包来构建依赖的问题。\n第二个就是依赖版本的控制， 这个怎么理解呢？比如 我们的 Web 应用的版本是 1.0， 而所依赖某个组件， 比如组件 A 的版本可能是 0.1。 组件 A 由专门的开发组来维护。 \n随着时间的推移， 我们的Web 应用可能升级到了 2.3， 而组件因为一直稳定所以还是0.1.  有一天突然有一个安全问题， 导致所有应用的组件 A 都需要升级到 0.5。\n步骤：\n​\t\n\n\n\n\n\n\n### 构建自动化\n\n> \n\nmaven 的生命周期指项目的构建过程，它包含了一系列有序的阶段\n\n\n## Maven 的优势\n\n","slug":"sync_blog/Maven 分享","published":1,"date":"2016-09-06T12:27:36.000Z","updated":"2016-09-09T03:48:27.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cisv8gvwo0006bumrx1pe35no","content":"<h1 id=\"Maven-是什么？\"><a href=\"#Maven-是什么？\" class=\"headerlink\" title=\"Maven 是什么？\"></a>Maven 是什么？</h1><h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>Maven 是什么？ </p>\n<blockquote>\n<p> Maven 是一种工具。 </p>\n</blockquote>\n<p>工具又是用来干嘛的呢？</p>\n<blockquote>\n<p> 工具是用来解决目前大家遇到的一些共性的、复杂的、耗时的问题。</p>\n</blockquote>\n<p>那么， Maven 是用来解决哪些问题的呢？</p>\n<h2 id=\"过去\"><a href=\"#过去\" class=\"headerlink\" title=\"过去\"></a>过去</h2><p>在很久很久以前，我们在新建项目时，需要添加项目的源码目录 <code>src</code>，包目录 <code>lib</code>，资源目录 <code>WebRoot/WebContent/web</code> 等等.</p>\n<p><img src=\"http://7xjzby.com1.z0.glb.clouddn.com/openfire_src_dir_160909_1.png\" alt=\"Openfire 源码目录\"><img src=\"http://7xjzby.com1.z0.glb.clouddn.com/simple_web_src_dir_160909.png\" alt=\"Simple Web src dir\"></p>\n<p>我们可以发现， 不同项目的目录结构，各有各的风格。</p>\n<p>这就会让我们在接触一个新的项目时，感到困惑。也不利于初学者的入门。</p>\n<p>然后，我们需要去不同的网站上下载项目所需要依赖的各种 jar 包，比如 Spring，junit 等等。 找 jar 包这个过程很痛苦， 做过的人都应该有所了解。 </p>\n<p>而比较有经验的工程师可能都会有自己的一个 jar 库， 当然， jar 的版本比较老也是免不了的。</p>\n<p>在这个过程中， 我们需要找到合适的版本比如 aspectjrt-1.5.1.jar， 合适的依赖包 aspectjweaver-1.5.1.jar。<br>多个 jar 包之间版本要兼容等等相关的问题。比如 spring-2.5.6.jar 需要依赖 slf4j-1.3.jar， 而 MyBatis 可能需要依赖 slf4j-1.5.jar. 这个时候还需要解决重复依赖的问题， 选择一个更兼容的版本。</p>\n<p>jar 包找齐之后， 我们还需要把对于 jar 包的依赖，添加到项目的 classpath 中（eclipse，不同的 IDE 下 classpath 的依赖是不同的)。</p>\n<p>在最终的版本库（svn）中，除了项目必要的源码，可能还会包含各种 jar 包以及 classpath 之类相关 IDE 配置。</p>\n<p>总而言之，解决 jar 包的依赖，是传统的项目开发中一项不容忽视的工作。</p>\n<p>目前来看，至少有三个比较繁琐的步骤：</p>\n<ol>\n<li>项目目录结构的生成， 规范性；</li>\n<li>和 jar 包相关的使用和管理，依赖问题；</li>\n<li>在版本库中包含了过多与项目自身无关的内容；</li>\n</ol>\n<h2 id=\"现在\"><a href=\"#现在\" class=\"headerlink\" title=\"现在\"></a>现在</h2><p>那么 Maven 是又通过哪种方式解决了这个繁琐的问题？</p>\n<p>Maven 使用惯例优于配置的原则。</p>\n<p>它要求在没有定制之前，所有的项目都有如下的结构： </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">目录</th>\n<th>目的</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">${basedir}</td>\n<td>存放 pom.xml和所有的子目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">${basedir}/src/main/java</td>\n<td>项目的 java源代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">${basedir}/src/main/resources</td>\n<td>项目资源，如各种配置文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">${basedir}/src/test/java</td>\n<td>项目的测试类，比如说 JUnit代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">${basedir}/src/test/resources</td>\n<td>测试使用的资源</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">${basedir}/src/main/webapp</td>\n<td>存放所有的 Web 资源, 比如 WEB-INF, 静态资源等</td>\n</tr>\n</tbody>\n</table>\n<p>Maven 为什么要使用惯例优于配置的原则？<br>一方面，统一项目结构，降低大家看到新项目时的学习成本；<br>另一方面，方便我们直接进行使用；</p>\n<blockquote>\n<p>演示 Maven 新建项目, 展示默认约定的目录结构</p>\n<p>引入 pom &amp; mvn 项目常用的生命周期</p>\n<p>引入 介绍 .m2 目录下的 .settings &amp; repository</p>\n</blockquote>\n<p>Maven 提供了一种方式， 让每一个组件都可以拥有自己的 location 坐标。<br>groupId + articleId + version + [type]。<br>eg.  <code>org.springframework.spring-mvc-3.2.2.jar</code></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-mvc&lt;/artifactId&gt;\n    &lt;version&gt;3.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><p>通过在项目中配置所需依赖包的 location， 我们就可以让项目自动依赖所需的 jar 包。<br>jar 包之间所有的依赖关系， maven 会自动进行处理。当然我们可以通过手工修改配置的方式来制定不同的依赖版本， 但大多数情况下是不必要的。 </p>\n<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>不知道大家过去有没有开发过存在多个项目依赖的 Web应用。 </p>\n<p>假如， 现在有这样一个场景， 公司 C 有多个项目组， 其中有架构组（F） 负责缓存 日志等公用服务，基础资源组（B） - 有系统公用资源层的开发 负责用户 角色 资源的基础服务， Web 应用开发组（W） - 负责最终的商业项目开发， 还有负责不同业务线的开发小组。 </p>\n<p>现在， 我们的系统架构是这样</p>\n<p>Web 应用 1<br>业务组件 A | 业务组件 B<br>基础资源组件<br>架构组件</p>\n<p>Web 应用 2<br>业务组件 A | 业务组件 C<br>基础资源组件<br>架构组件</p>\n<p>上面是公司的技术部架构</p>\n<p>接下来，说一下项目的具体场景</p>\n<p>我们的 Web 应用 1， 假设目前的  Release 版本号是 2.0.   它所依赖的架构组件， 版本号是 0.1.<br>现在因为发现了一个安全问题， 版本号要更新到最新的  0.2.</p>\n<p>传统的步骤：</p>\n<pre><code>1. 架构组 打包项目， F-0.2.jar\n2. 把打包好的组件发给其他项目组， 并通知其他项目组， 替换 组件\n3. 所有涉及到的项目，备份 F-0.1.jar , 升级到 F-0.2.jar ， 如果 F-0.2.jar 有了新的依赖 比如 aspect.jar， 那么我们的项目中也需要导入它所依赖的 jar 包\n&gt; 解决jar 包依赖问题一直都是很烦人的问题\n4. 测试 - 如果组件 A 存在问题， 重复 1 - 4 步\n5. 发布项目\n</code></pre><p>Maven：</p>\n<pre><code>1. 修改项目版本号， deploy 到 maven 私有仓库（存放 jar 包的地方）\n2. 邮件通知到相关项目组， 更新版本号\n3. 涉及到的项目更新组件版本号\n4. 测试 - 如果组件出现问题， 重复执行  deploy，通知相关人员，测试 即可， 不需要不断的发包给别人 也无需解决 jar 依赖的问题\n5. 发布项目\n</code></pre><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Maven 是一个项目管理 &amp; 构建自动化工具。<br>它有很强大的依赖管理功能， 可以帮助我们简化项目之间的依赖关系。</p>\n<h3 id=\"依赖管理\"><a href=\"#依赖管理\" class=\"headerlink\" title=\"依赖管理\"></a>依赖管理</h3><p>怎么理解呢？</p>\n<p>对于 Java 项目来讲， 每一个项目都会或多或少的依赖一些 jar 包。<br>而每个 jar 其实都是一个已经发布的项目。也就是说我们的项目其实已经依赖了各种各样的项目， 比如 Spring，Hibernate etc..<br>从另一个角度来讲，这也就意味着，我们可以通过maven， 把所有的 jar 包(项目)管理起来。</p>\n<p>QA</p>\n<h3 id=\"项目管理\"><a href=\"#项目管理\" class=\"headerlink\" title=\"项目管理\"></a>项目管理</h3><p>那么，我们既然可以通过 Maven 引用别人的项目，那么是不是意味着我们自己的项目，如果是由多个子项目来构成，那也可以通过 Maven 来组织呢？</p>\n<p>多项目之间的依赖， 首先 第一个问题，就是我们需要通过 IDE 的项目依赖配置， 来解决开发过程中不断打 jar 包来构建依赖的问题。<br>第二个就是依赖版本的控制， 这个怎么理解呢？比如 我们的 Web 应用的版本是 1.0， 而所依赖某个组件， 比如组件 A 的版本可能是 0.1。 组件 A 由专门的开发组来维护。<br>随着时间的推移， 我们的Web 应用可能升级到了 2.3， 而组件因为一直稳定所以还是0.1.  有一天突然有一个安全问题， 导致所有应用的组件 A 都需要升级到 0.5。<br>步骤：<br>​    </p>\n<h3 id=\"构建自动化\"><a href=\"#构建自动化\" class=\"headerlink\" title=\"构建自动化\"></a>构建自动化</h3><blockquote>\n</blockquote>\n<p>maven 的生命周期指项目的构建过程，它包含了一系列有序的阶段</p>\n<h2 id=\"Maven-的优势\"><a href=\"#Maven-的优势\" class=\"headerlink\" title=\"Maven 的优势\"></a>Maven 的优势</h2>","excerpt":"","more":"<h1 id=\"Maven-是什么？\"><a href=\"#Maven-是什么？\" class=\"headerlink\" title=\"Maven 是什么？\"></a>Maven 是什么？</h1><h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>Maven 是什么？ </p>\n<blockquote>\n<p> Maven 是一种工具。 </p>\n</blockquote>\n<p>工具又是用来干嘛的呢？</p>\n<blockquote>\n<p> 工具是用来解决目前大家遇到的一些共性的、复杂的、耗时的问题。</p>\n</blockquote>\n<p>那么， Maven 是用来解决哪些问题的呢？</p>\n<h2 id=\"过去\"><a href=\"#过去\" class=\"headerlink\" title=\"过去\"></a>过去</h2><p>在很久很久以前，我们在新建项目时，需要添加项目的源码目录 <code>src</code>，包目录 <code>lib</code>，资源目录 <code>WebRoot/WebContent/web</code> 等等.</p>\n<p><img src=\"http://7xjzby.com1.z0.glb.clouddn.com/openfire_src_dir_160909_1.png\" alt=\"Openfire 源码目录\"><img src=\"http://7xjzby.com1.z0.glb.clouddn.com/simple_web_src_dir_160909.png\" alt=\"Simple Web src dir\"></p>\n<p>我们可以发现， 不同项目的目录结构，各有各的风格。</p>\n<p>这就会让我们在接触一个新的项目时，感到困惑。也不利于初学者的入门。</p>\n<p>然后，我们需要去不同的网站上下载项目所需要依赖的各种 jar 包，比如 Spring，junit 等等。 找 jar 包这个过程很痛苦， 做过的人都应该有所了解。 </p>\n<p>而比较有经验的工程师可能都会有自己的一个 jar 库， 当然， jar 的版本比较老也是免不了的。</p>\n<p>在这个过程中， 我们需要找到合适的版本比如 aspectjrt-1.5.1.jar， 合适的依赖包 aspectjweaver-1.5.1.jar。<br>多个 jar 包之间版本要兼容等等相关的问题。比如 spring-2.5.6.jar 需要依赖 slf4j-1.3.jar， 而 MyBatis 可能需要依赖 slf4j-1.5.jar. 这个时候还需要解决重复依赖的问题， 选择一个更兼容的版本。</p>\n<p>jar 包找齐之后， 我们还需要把对于 jar 包的依赖，添加到项目的 classpath 中（eclipse，不同的 IDE 下 classpath 的依赖是不同的)。</p>\n<p>在最终的版本库（svn）中，除了项目必要的源码，可能还会包含各种 jar 包以及 classpath 之类相关 IDE 配置。</p>\n<p>总而言之，解决 jar 包的依赖，是传统的项目开发中一项不容忽视的工作。</p>\n<p>目前来看，至少有三个比较繁琐的步骤：</p>\n<ol>\n<li>项目目录结构的生成， 规范性；</li>\n<li>和 jar 包相关的使用和管理，依赖问题；</li>\n<li>在版本库中包含了过多与项目自身无关的内容；</li>\n</ol>\n<h2 id=\"现在\"><a href=\"#现在\" class=\"headerlink\" title=\"现在\"></a>现在</h2><p>那么 Maven 是又通过哪种方式解决了这个繁琐的问题？</p>\n<p>Maven 使用惯例优于配置的原则。</p>\n<p>它要求在没有定制之前，所有的项目都有如下的结构： </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">目录</th>\n<th>目的</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">${basedir}</td>\n<td>存放 pom.xml和所有的子目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">${basedir}/src/main/java</td>\n<td>项目的 java源代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">${basedir}/src/main/resources</td>\n<td>项目资源，如各种配置文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">${basedir}/src/test/java</td>\n<td>项目的测试类，比如说 JUnit代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">${basedir}/src/test/resources</td>\n<td>测试使用的资源</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">${basedir}/src/main/webapp</td>\n<td>存放所有的 Web 资源, 比如 WEB-INF, 静态资源等</td>\n</tr>\n</tbody>\n</table>\n<p>Maven 为什么要使用惯例优于配置的原则？<br>一方面，统一项目结构，降低大家看到新项目时的学习成本；<br>另一方面，方便我们直接进行使用；</p>\n<blockquote>\n<p>演示 Maven 新建项目, 展示默认约定的目录结构</p>\n<p>引入 pom &amp; mvn 项目常用的生命周期</p>\n<p>引入 介绍 .m2 目录下的 .settings &amp; repository</p>\n</blockquote>\n<p>Maven 提供了一种方式， 让每一个组件都可以拥有自己的 location 坐标。<br>groupId + articleId + version + [type]。<br>eg.  <code>org.springframework.spring-mvc-3.2.2.jar</code></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-mvc&lt;/artifactId&gt;\n    &lt;version&gt;3.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><p>通过在项目中配置所需依赖包的 location， 我们就可以让项目自动依赖所需的 jar 包。<br>jar 包之间所有的依赖关系， maven 会自动进行处理。当然我们可以通过手工修改配置的方式来制定不同的依赖版本， 但大多数情况下是不必要的。 </p>\n<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>不知道大家过去有没有开发过存在多个项目依赖的 Web应用。 </p>\n<p>假如， 现在有这样一个场景， 公司 C 有多个项目组， 其中有架构组（F） 负责缓存 日志等公用服务，基础资源组（B） - 有系统公用资源层的开发 负责用户 角色 资源的基础服务， Web 应用开发组（W） - 负责最终的商业项目开发， 还有负责不同业务线的开发小组。 </p>\n<p>现在， 我们的系统架构是这样</p>\n<p>Web 应用 1<br>业务组件 A | 业务组件 B<br>基础资源组件<br>架构组件</p>\n<p>Web 应用 2<br>业务组件 A | 业务组件 C<br>基础资源组件<br>架构组件</p>\n<p>上面是公司的技术部架构</p>\n<p>接下来，说一下项目的具体场景</p>\n<p>我们的 Web 应用 1， 假设目前的  Release 版本号是 2.0.   它所依赖的架构组件， 版本号是 0.1.<br>现在因为发现了一个安全问题， 版本号要更新到最新的  0.2.</p>\n<p>传统的步骤：</p>\n<pre><code>1. 架构组 打包项目， F-0.2.jar\n2. 把打包好的组件发给其他项目组， 并通知其他项目组， 替换 组件\n3. 所有涉及到的项目，备份 F-0.1.jar , 升级到 F-0.2.jar ， 如果 F-0.2.jar 有了新的依赖 比如 aspect.jar， 那么我们的项目中也需要导入它所依赖的 jar 包\n&gt; 解决jar 包依赖问题一直都是很烦人的问题\n4. 测试 - 如果组件 A 存在问题， 重复 1 - 4 步\n5. 发布项目\n</code></pre><p>Maven：</p>\n<pre><code>1. 修改项目版本号， deploy 到 maven 私有仓库（存放 jar 包的地方）\n2. 邮件通知到相关项目组， 更新版本号\n3. 涉及到的项目更新组件版本号\n4. 测试 - 如果组件出现问题， 重复执行  deploy，通知相关人员，测试 即可， 不需要不断的发包给别人 也无需解决 jar 依赖的问题\n5. 发布项目\n</code></pre><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Maven 是一个项目管理 &amp; 构建自动化工具。<br>它有很强大的依赖管理功能， 可以帮助我们简化项目之间的依赖关系。</p>\n<h3 id=\"依赖管理\"><a href=\"#依赖管理\" class=\"headerlink\" title=\"依赖管理\"></a>依赖管理</h3><p>怎么理解呢？</p>\n<p>对于 Java 项目来讲， 每一个项目都会或多或少的依赖一些 jar 包。<br>而每个 jar 其实都是一个已经发布的项目。也就是说我们的项目其实已经依赖了各种各样的项目， 比如 Spring，Hibernate etc..<br>从另一个角度来讲，这也就意味着，我们可以通过maven， 把所有的 jar 包(项目)管理起来。</p>\n<p>QA</p>\n<h3 id=\"项目管理\"><a href=\"#项目管理\" class=\"headerlink\" title=\"项目管理\"></a>项目管理</h3><p>那么，我们既然可以通过 Maven 引用别人的项目，那么是不是意味着我们自己的项目，如果是由多个子项目来构成，那也可以通过 Maven 来组织呢？</p>\n<p>多项目之间的依赖， 首先 第一个问题，就是我们需要通过 IDE 的项目依赖配置， 来解决开发过程中不断打 jar 包来构建依赖的问题。<br>第二个就是依赖版本的控制， 这个怎么理解呢？比如 我们的 Web 应用的版本是 1.0， 而所依赖某个组件， 比如组件 A 的版本可能是 0.1。 组件 A 由专门的开发组来维护。<br>随着时间的推移， 我们的Web 应用可能升级到了 2.3， 而组件因为一直稳定所以还是0.1.  有一天突然有一个安全问题， 导致所有应用的组件 A 都需要升级到 0.5。<br>步骤：<br>​    </p>\n<h3 id=\"构建自动化\"><a href=\"#构建自动化\" class=\"headerlink\" title=\"构建自动化\"></a>构建自动化</h3><blockquote>\n</blockquote>\n<p>maven 的生命周期指项目的构建过程，它包含了一系列有序的阶段</p>\n<h2 id=\"Maven-的优势\"><a href=\"#Maven-的优势\" class=\"headerlink\" title=\"Maven 的优势\"></a>Maven 的优势</h2>"}],"PostAsset":[{"_id":"source/_posts/life-simple/lijiang.jpg","slug":"lijiang.jpg","post":"cisv8gvw70001bumr5481pohe","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cisv8gvw20000bumrm0wv126d","tag_id":"cisv8gvwa0002bumrfobiwlib","_id":"cisv8gvwh0004bumriw1fq8rp"},{"post_id":"cisv8gvw70001bumr5481pohe","tag_id":"cisv8gvwg0003bumrry6p5dr5","_id":"cisv8gvwk0005bumrt5c7ejkh"}],"Tag":[{"name":"始","_id":"cisv8gvwa0002bumrfobiwlib"},{"name":"随想","_id":"cisv8gvwg0003bumrry6p5dr5"}]}}